# 面经

## 1.请你分别介绍一下单元测试、集成测试、系统测试、验收测试、回归测试

单元测试：针对最小模块的测试，由开发采用白盒测试;

集成测试：介于单元测试和系统测试之间，验证检查各个模块接口是否能正常连接使用;

系统测试：通过冒烟测试后，进行功能测试以及接口测试，性能测试等，把所有的功能都运行一遍，保证整个产品的质量;

验收测试：系统测试全部通过后，由产品，开发等以及最终用户体验；

回归测试：针对修复过的BUG，进行再一次的测试，避免bug的重现;

## 2.请你回答一下单元测试、集成测试、系统测试、验收测试、回归测试这几步中最重要的是哪一步

系统测试。因为系统测试是对整个系统进行到的测试，能够覆盖所有模块，它在整个测试过程中起到承上启下的作用，既可以验证系统的功能完整性、性能特性，同时能验证系统是否符合需求规格说明书，也为后续的验收测试、回归测试提供依据和保障。

## 3.请回答集成测试和系统测试的区别，以及它们的应用场景主要是什么？

区别：

1.测试依据不一样

集成测试的依据是概要设计说明书；系统测试的依据是需求规格说明书

2.测试对象不一样

集成测试的测试对象是模块，接口；系统测试的测试对象是整个系统

3.测试重点不一样

集成测试的测试重点是函数代码是否和概要设计说明书一致，函数之间互相调用是否正确，模块功能以及数据传输是否正确；系统测试的测试重点是检查软件是否和需求规格说明书一致，功能测试，性能测试，安全测试等

4.测试方法不一样

集成测试的方法是灰盒测试，系统测试的方法是黑盒测试

5.测试完整性的评估标准不一样

集成测试的评估标准是接口覆盖率，系统测试是的评估标准是需求覆盖率

应用场景：集成测试用于测试程序模块之间的接口，系统测试用于测试整个系统的功能等

## 4.请问测试开发需要哪些知识？需要具备什么能力？

知识：1.软件测试基础2.自动化测试工具3.计算机基础知识4.测试框架

能力：专业技术、沟通表达、逻辑分析、业务分析、缺陷察觉、团队协作、问题解决、宏观把控。

## 5.请说一说黑盒与白盒的测试方法

黑盒测试： 黑盒测试也称功能测试或数据驱动测试，它是在已知产品所应具有的功能，通过测试来检测每个功能是否都能正常使用，在测试时，把程序看作一个不能打开的黑盆子，在完全不考虑程序内部结构和内部特性的情况下，测试者在程序接口进行测试，它只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数锯而产生正确的输出信息，并且保持外部信息（如数据库或文件）的完整性。 “黑盒”法着眼于程序外部结构、不考虑内部逻辑结构、针对软件界面和软件功能进行测试。“黑盒”法是穷举输入测试，只有把所有可能的输入都作为测试情况使用，才能以这种方法查出程序中所有的错误。实际上测试情况有无穷多个，因此不仅要测试所有合法的输入，而且还要对那些不合法但是可能的输入进行测试。 常用的黑盒测试方法有：等价类划分法；边界值分析法；因果图法；场景法；正交实验设计法；判定表驱动分析法；错误推测法；功能图分析法。 

白盒测试： 白盒测试也称为结构测试或逻辑驱动测试，是针对被测单元内部是如何进行工作的测试。它根据程序的控制结构设计测试用例，主要用于软件或程序验证。白盒测试法检查程序内部逻辑结构，对所有的逻辑路径进行测试，是一种穷举路径的测试方法，但即使每条路径都测试过了，但仍然有可能存在错误。因为：穷举路径测试无法检查出程序本身是否违反了设计规范，即程序是否是一个错误的程序；穷举路径测试不可能检查出程序因为遗漏路径而出错；穷举路径测试发现不了一些与数据相关的错误。 白盒测试需要遵循的原则有：

1. 保证一个模块中的所有独立路径至少被测试一次
  
2. 所有逻辑值均需要测试真（true）和假（false）；两种情况；
  
3. 检查程序的内部数据结构，保证其结构的有效性；
  
4. 在上下边界及可操作范围内运行所有循环。 常用白盒测试方法： 静态测试：不用运行程序的测试，包括代码检查、静态结构分析、代码质量度量、文档测试等等，它可以由人工进行，充分发挥人的逻辑思维优势，也可以借助软件工具（Fxcop）自动进行。 动态测试：需要执行代码，通过运行程序找到问题，包括功能确认与接口测试、覆盖率分析、性能分析、内存分析等。 白盒测试中的逻辑覆盖包括语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖和路径覆盖。六种覆盖标准发现错误的能力呈由弱到强的变化：
  

 1.语句覆盖每条语句至少执行一次。

 2.判定覆盖每个判定的每个分支至少执行一次。

 3.条件覆盖每个判定的每个条件应取到各种可能的值。

 4.判定/条件覆盖同时满足判定覆盖条件覆盖。

 5.条件组合覆盖每个判定中各条件的每一种组合至少出现一次。

 6.路径覆盖使程序中每一条可能的路径至少执行一次。

## 6.请说一下手动测试与自动化测试的优缺点

手工测试缺点：

 1、重复的手工回归测试，代价昂贵、容易出错。

 2、依赖于软件测试人员的能力。

手工测试优点：

 1、测试人员具有经验和对错误的猜测能力。

 2、测试人员具有审美能力和心理体验。

 3、测试人员具有是非判断和逻辑推理能力。

自动化测试的优点：

 1、对程序的回归测试更方便。这可能是自动化测试最主要的任务，特别是在程序修改比较频繁时，效果是非常明显的。由于回归测试的动作和用例是完全设计好的，测试期望的结果也是完全可以预料的，将回归测试自动运行，可以极大提高测试效率，缩短回归测试时间。

 2、可以运行更多更繁琐的测试。自动化的一个明显的好处是可以在较少的时间内运行更多的测试。

 3、可以执行一些手工测试困难或不可能进行的测试。比如，对于大量用户的测试，不可能同时让足够多的测试人员同时进行测试，但是却可以通过自动化测试模拟同时有许多用户，从而达到测试的目的。

 4、更好地利用资源。将繁琐的任务自动化，可以提高准确性和测试人员的积极性，将测试技术人员解脱出来投入更多精力设计更好的测试用例。有些测试不适合于自动测试，仅适合于手工测试，将可自动测试的测试自动化后，可以让测试人员专注于手工测试部分，提高手工测试的效率。

 5、测试具有一致性和可重复性。由于测试是自动执行的，每次测试的结果和执行的内容的一致性是可以得到保障的，从而达到测试的可重复的效果。

 6、测试的复用性。由于自动测试通常采用脚本技术，这样就有可能只需要做少量的甚至不做修改，实现在不同的测试过程中使用相同的用例。  7、增加软件信任度。由于测试是自动执行的，所以不存在执行过程中的疏忽和错误，完全取决于测试的设计质量。一旦软件通过了强有力的自动测试后，软件的信任度自然会增加。

自动化测试的缺点：

1、不能取代手工测试 

2、手工测试比自动测试发现的缺陷更多 

3、对测试质量的依赖性极大

4、测试自动化不能提高有效性

5、测试自动化可能会制约软件开发。由于自动测试比手动测试更脆弱，所以维护会受到限制，从而制约软件的开发。 

6、工具本身并无想像力

## 7.请问你怎么看待软件测试的潜力和挑战

软件测试的潜力在于；随着人工智能等新型信息技术的发展，软件测试也将随之开发一些高端的自动化测试框架，减少人工测试的工作量。挑战在于：需要挑战原始的测试方法和流程，使用新的测试方法和测试程序，以便发现更多的问题，提升软件产品的质量。

## 8.你觉得软件测试的核心竞争力是什么

软件测试的核心竞争力在于早发现问题和发现别人不能发现的问题。 1.问题发现的越早，解决成本越低。 2.发现别人不能发现的问题，那就证明你是无可替代的。

## 9.你觉得测试和开发需要怎么结合才能使软件的质量得到更好的保障

测试和开发应该按照w模型的方式进行结合，实现测试和开发同步进行，这样做能尽早发现软件缺陷，减少软件开发成本。v模型是将测试放在了开发的后半部分，这样做会导致测试时不能及时发现需求功能缺陷，等到最后验证时会出现大量问题，从而增加开发成本。而w模型能够在开发过程中同步测试，及时发现缺陷，不仅能够测试产品的程序，还能测试需求和设计，大大减少了开发成本，提高了开发效率。

## 10.你觉得单元测试可行吗

可行，单元测试可以有效地测试某个程序模块的行为，是未来重构代码的信心保证。事前可以保证质量，事后可以快速复现问题，并在修改代码后做回归自测。可行性考虑的是要用一些可行的方法做到关键的代码可测试，如通过边界条件、等价类划分、错误、因果，设计测试用例要覆盖常用的输入组合、边界条件和异常。

## 11.你觉得自动化测试有什么意义，都需要做些什么

自动化测试的意义在于 

1、可以对程序的新版本自动执行回归测试;

2、可以执行手工测试困难或者不可能实现的测试，如压力测试，并发测试;

3、能够更好的利用资源，节省时间和人力 执行自动化测试之前首先判断这个项目是不是和推广自动化测试，然后对项目做需求分析，指定测试计划，搭建自动化测试框架，设计测试用例，执行测试，评估;

## 12.请你回答一下测试的相关流程是什么？

测试最规范的过程如下 需求测试->概要设计测试->详细设计测试->单元测试->集成测试->系统测试->验收测试

## 13.请你说一下如何写测试用例

1、测试人员尽早介入，彻底理解清楚需求，这个是写好测试用例的基础

2、如果以前有类似的需求，可以参考类似需求的测试用例，然后还需要看类似需求的bug情况

3、清楚输入、输出的各种可能性，以及各种输入的之间的关联关系，理解清楚需求的执行逻辑，通过等价类、边界值、判定表等方法找出大部分用例

4、找到需求相关的一些特性，补充测试用例

5、根据自己的经验分析遗漏的测试场景

6、多总结类似功能点的测试点，才能够写出质量越来越高的测试用例

7、书写格式一定要清晰

## 14.请问你觉得测试项目具体工作是什么？

搭建测试环境 撰写测试用例 执行测试用例 写测试计划，测试报告

测试，并提交BUG表单 跟踪bug修改情况 执行自动化测试，编写脚本，执行，分析，报告 进行性能测试，压力测试等其他测试，执行，分析，调优，报告

## 15.请问如果想进行bug的测评，怎么去评测bug？

Bug的priority（）和severity（）是两个重要属性，通常人员在提交bug的时候，只定义severity，而将priority交给leader定义，通常bug管理中，severity分为四个等级blocker、critical、major、minor/trivial，而priority分为五个等级immediate、urgent、high、normal、low。 Severity： 1、blocker：即系统无法执行，崩溃，或严重资源不足，应用模块无法启动或异常退出，无法测试，造成系统不稳定。常见的有严重花屏、内存泄漏、用户数据丢失或破坏、系统崩溃/死机/冻结、模块无法启动或异常退出、严重的数值计算错误、功能设计与需求严重不符、其它导致无法测试的错误， 如服务器500错误。 2、critical：即映像系统功能或操作，主要功能存在严重缺陷，但不会映像到系统稳定性。常见的有：功能未实现，功能错误、系统刷新错误、数据通讯错误、轻微的数值计算错误、影响功能及界面的错误字或拼写错误。 3、major：即界面、性能缺陷、兼容性，常见的有：操作界面错误，边界条件错误，提示信息错误，长时间操作无进度提示，系统未优化，兼容性问题。 4、minor/trivial：即易用性及建议性问题。 Priority 1、immediate：即马上解决， 2、urgent：急需解决 3、high：高度重视，有时间要马上解决 4、low：在系统发布前解决，或确认可以不用解决。

## 16.请你说一说测试用例的边界

边界值分析法就是对输入或输出的边界值进行测试的一种黑盒测试方法。

通常边界值分析法是作为对等价类划分法的补充，这种情况下，其测试用例来自等价类的边界。

常见的边界值

1)对16-bit 的整数而言 32767 和 -32768 是边界

2)屏幕上光标在最左上、最右下位置

3)报表的第一行和最后一行

4)数组元素的第一个和最后一个

5)循环的第 0 次、第 1 次和倒数第 2 次、最后一次

## 17.请你说一下软件质量的六个特征

软件质量可以用下列特征来评价：

a.功能特征：与一组功能及其指定性质有关的一组属性，这里的功能是满足明确或隐含的需求的那些功能。

b.可靠特征：在规定的一段时间和条件下，与软件维持其性能水平的能力有关的一组属性。

c.易用特征：由一组规定或潜在的用户为使用软件所需作的努力和所作的评价有关的一组属性。

d.效率特征：与在规定条件下软件的性能水平与所使用资源量之间关系有关的一组属性。

e.可维护特征：与进行指定的修改所需的努力有关的一组属性。

f.可移植特征：与软件从一个环境转移到另一个环境的能力有关的一组属性。

## 18.请你说一下设计测试用例的方法

黑盒测试：

1.等价类划分 等价类划分是将系统的输入域划分为若干部分，然后从每个部分选取少量代表性数据进行测试。等价类可以划分为有效等价类和无效等价类，设计测试用例的时候要考虑这两种等价类。

2.边界值分析法 边界值分析法是对等价类划分的一种补充，因为大多数错误都在输入输出的边界上。边界值分析就是假定大多数错误出现在输入条件的边界上，如果边界附件取值不会导致程序出错，那么其他取值出错的可能性也就很小。 边界值分析法是通过优先选择不同等价类间的边界值覆盖有效等价类和无效等价类来更有效的进行测试，因此该方法要和等价类划分法结合使用。

3.正交试验法 正交是从大量的试验点中挑选出适量的、有代表性的点。正交试验设计是研究多因素多水平的一种设计方法，他是一种基于正交表的高效率、快速、经济的试验设计方法。

4.状态迁移法 状态迁移法是对一个状态在给定的条件内能够产生需要的状态变化，有没有出现不可达的状态和非法的状态，状态迁移法是设计足够的用例达到对系统状态的覆盖、状态、条件组合、状态迁移路径的覆盖。

5.流程分析法 流程分析法主要针对测试场景类型属于流程测试场景的测试项下的测试子项进行设计，这是从白盒测试中路径覆盖分析法借鉴过来的一种很重要的方法。

6.输入域测试法 输入域测试法是针对输入会有各种各样的输入值的一个测试，他主要考虑 极端测试、中间范围测试，特殊值测试 。

7.输出域分析法 输出域分析法是对输出域进行等价类和边界值分析，确定是要覆盖的输出域样点，反推得到应该输入的输入值，从而构造出测试用例，他的目的是为了达到输出域的等价类和边界值覆盖。

8.判定表分析法 判定表是分析和表达多种输入条件下系统执行不同动作的工具，他可以把复杂的逻辑关系和多种条件组合的情况表达的即具体又明确；

9.因果图法 因果图是用于描述系统输入输出之间的因果关系、约束关系。因果图的绘制过程是对被测系统的外部特征的建模过程，根据输入输出间的因果图可以得到判定表，从而规划出测试用例。

10.错误猜测法 错误猜测法主要是针对系统对于错误操作时对于操作的处理法的猜测法，从而设计测试用例

11.异常分析法 异常分析法是针对系统有可能存在的异常操作，软硬件缺陷引起的故障进行分析，分析发生错误时系统对于错误的处理能力和恢复能力依此设计测试用例。

白盒测试： 白盒测试也称为结构测试或逻辑驱动测试，是针对被测单元内部是如何进行工作的测试。它根据程序的控制结构设计测试用例，主要用于软件或程序验证。白盒测试法检查程序内部逻辑结构，对所有的逻辑路径进行测试，是一种穷举路径的测试方法，但即使每条路径都测试过了，但仍然有可能存在错误。因为：穷举路径测试无法检查出程序本身是否违反了设计规范，即程序是否是一个错误的程序；穷举路径测试不可能检查出程序因为遗漏路径而出错；穷举路径测试发现不了一些与数据相关的错误。

白盒测试需要遵循的原则有：

1.保证一个模块中的所有独立路径至少被测试一次；

2.所有逻辑值均需要测试真（true）和假（false）；两种情况；

3.检查程序的内部数据结构，保证其结构的有效性；

4.在上下边界及可操作范围内运行所有循环。

常用白盒测试方法： 静态测试：不用运行程序的测试，包括代码检查、静态结构分析、代码质量度量、文档测试等等，它可以由人工进行，充分发挥人的逻辑思维优势，也可以借助软件工具（Fxcop）自动进行。 动态测试：需要执行代码，通过运行程序找到问题，包括功能确认与接口测试、覆盖率分析、性能分析、内存分析等。 白盒测试中的逻辑覆盖包括语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖和路径覆盖。

六种覆盖标准发现错误的能力呈由弱到强的变化：

1.语句覆盖每条语句至少执行一次。

2.判定覆盖每个判定的每个分支至少执行一次。

3.条件覆盖每个判定的每个条件应取到各种可能的值。

4.判定/条件覆盖同时满足判定覆盖条件覆盖。

5.条件组合覆盖每个判定中各条件的每一种组合至少出现一次。

6.路径覆盖使程序中每一条可能的路径至少执行一次。

## 19.请你说一说测试工程师的必备技能

需要具备的知识:

1.软件测试基础理论

2.计算机基础知识

3.自动化测试工具

4.编程语言知识

需要具备的能力:

1.业务分析能力

2.缺陷洞察能力

3.逻辑思考能力

4.专业技术能力

5.团队协作能力

6.问题解决能力

7.沟通表达能力

8.宏观把控能力

## 20.请你说一下app性能测试的指标

1.内存 2.cpu 3.电量 4.流量 5.启动速度 6.滑动速度、界面切换速度 7.与服务器交互的网络速度

## 21.请你说一说app测试的工具

①接口测试：postman、②性能测试:jmeter、③抓包工具:charles,fiddler、④内存、CPU、电量测试:GT,soloPi ⑤弱网测试:chales ⑥ui测试:uiautomator2,appinum,atx ⑦稳定性测试:monkey,maxim,uicrawler,appcrawler、 ⑧兼容性测试:wetest,testin

## 22.请你说一说bug的周期，以及描述一下不同类别的bug

bug的周期：简单：①创建bug ②分配bug ③修复并测试 ④关闭 ⑤重新开启 ⑥无效 复杂：新建>>指派>>已经打开>>已经修复>>待测试>>再测试>>已关闭>>再次打开>>拒绝中>>已拒绝>>关闭>>延期 bug类型 • 代码错误 • 界面优化 • 设计缺陷 • 配置相关 • 安装部署 • 安全相关 • 性能问题 • 标准规范 • 测试脚本 • 其他

## 23.请你说一说测试的常用方法

回答应该是：手工测试、自动化测试 黑白灰盒测试 静态、动态测试

## 24.请你说一下黑盒白盒

黑盒：不考虑系统内部是如何实现的，对整个系统进行功能、UI、兼容性、易用性、可用性进行测试，保证整个系统能正常运行。白盒：对代码进行静态、动态测试，看代码是否按要求规范进行编写、是否存在逻辑错误等，主要是对代码进行审查。

## 25.请你说一说你知道的自动化测试框架

Selenium（Web应用程序自动化测试）

Appium（移动应用程序自动化测试）

TestComplete（桌面应用程序自动化测试）

JMeter（负载测试）

Robot Framework（通用自动化测试框架）

## 26.请你说一说web测试和app测试的不同点

系统架构方面： web项目，一般都是b/s架构，基于浏览器的 app项目，则是c/s的，必须要有客户端，用户需要安装客户端。 web测试只要更新了服务器端，客户端就会同步会更新。App项目则需要客户端和服务器都更新。 性能方面: web页面主要会关注响应时间 而app则还需要关心流量、电量、CPU、GPU、Memory这些。 它们服务端的性能没区别，都是一台服务器。 兼容方面： web是基于浏览器的，所以更倾向于浏览器和电脑硬件，电脑系统的方向的兼容 app测试则要看分辨率，屏幕尺寸，还要看设备系统。 web测试是基于浏览器的所以不必考虑安装卸载。 而app是客户端的，则必须测试安装、更新、卸载。除了常规的安装、更新、卸载还要考虑到异常场景。包括安装时的中断、弱网、安装后删除安装文件 。 此外APP还有一些专项测试：如网络、适配性。

## 27.请问你了解什么测试方法

等价类划分，边界值分析，错误推测，因果图法，逻辑覆盖法，程序插桩技术，基本路径法，符号测试，错误驱动测试

## 28.请问黑盒测试和白盒测试有哪些方法

黑盒测试方法有等价类划分，边界值分析，错误推测，因果图法

白盒测试方法有逻辑覆盖法，程序插桩技术，基本路径法，符号测试，错误驱动测试

## 29.请问你怎么看待测试，知道哪些测试的类型，有用过哪些测试方法？

测试是软件开发中不可或缺的一环，测试通过经济，高效的方法，捕捉软件中的错误，从而达到保重软件内在质量的目的。 测试分为功能测试和非功能测试，非功能测试又可以分为性能测试、压力测试、容量测试、健壮性测试、安全性测试、可靠性测试、恢复性测试、备份测试、协议测试、兼容性测试、可用性测试、配置测试、GUI测试。 测试方法用过等价划分法、边值分析法、错误推测法、因果图法。

## 30.请问你怎么测试网络协议

协议测试包括四种类型的测试

1、一致性测试：检测协议实现本身与协议规范的符合程度

2、互操作性测试：基于某一协议检测不同协议实现间互操作互通信的能力

3、性能测试：检测协议实现的性能指标，比如数据传输速度，连接时间，执行速度，吞吐量，并发度，

4、健壮性测试：检测协议是现在各种恶劣环境下运行的能力，比如注入干扰报文，通信故障，信道被切断

## 31.请你回答一下什么是α测试和β测试，以及什么时候用到他们

α测试：在受控的环境中进行，由用户在开发者的场所进行，并且在开发者对用户的指导下进行测试，开发者负责记录发现的错误和使用中遇到的问题 

β测试：在开发者不能控制的环境中的真实应用，由软件的最终用户们在一个或多个客户场所下进行，由用户记录在测试中遇到的一系列问题，并定期报给开发者。

## 32.给你一个字符串，你怎么判断是不是ip地址？手写这段代码，并写出测试用例

    class Solution {
      public:
        /**
         * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
         *
         * 验证IP地址
         * @param IP string字符串 一个IP地址字符串
         * @return string字符串
         */
      public:
        std::string solve(std::string IP) {
            if (IP.size() == 0) {
                return "Neither";
            }
            if (isIPv4(IP)) {
                return "IPv4";
            } else if (isIPv6(IP)) {
                return "IPv6";
            }
            return "Neither";
        }
      private:
        bool isIPv4(std::string IP) {
            std::vector<std::string> s = split(IP, ".");
            if (s.size() != 4) {
                return false;
            }
            for (int i = 0; i < s.size(); i++) {
                if (s[i].size() == 0) {
                    return false;
                }
                if (s[i].size() < 0 || s[i].size() > 3 || (s[i][0] == '0' &&
                        s[i].size() != 1)) {
                    return false;
                }
                for (int j = 0; j < s[i].size(); j++) {
                    if (!isdigit(s[i][j])) {
                        return false;
                    }
                }
                int num = stoi(s[i]);
                if (num < 0 || num > 255) {
                    return false;
                }
            }
            return true;
        }
    
        bool isIPv6(std::string IP) {
            std::vector<std::string> s = split(IP, ":");
            //IPv6必定为8组
            if (s.size() != 8)
                return false;
            for (int i = 0; i < s.size(); i++) {
                if (s[i].size() == 0 || s[i].size() > 4)
                    return false;
                for (int j = 0; j < s[i].size(); j++) {
                    if (!(isdigit(s[i][j]) || (s[i][j] >= 'a' && s[i][j] <= 'f') ||
                            (s[i][j] >= 'A' && s[i][j] <= 'F')))
                        return false;
                }
            }
            return true;
        }
    
        std::vector<std::string> split(std::string s, std::string spliter) {
            std::vector<std::string>res;
            int i;
            while ((i = s.find(spliter)) && i != s.npos) {
                res.push_back(s.substr(0, i));
                s = s.substr(i + 1);
            }
            res.push_back(s);
            return res;
        }
    };

测试用例：等价类划分法，A、B、C、D类，还有一些边界值，如全0，全255。再结合一些错误样例：比如带负数，比如超过255，比如包含其他字符，比如超出长度等

## 33.请进行测试用例设计：一串数字，闰年的判别

    #include<stdio.h>
    int main(){
        int year = 0;
        scanf("%d", &year);
        if (year % 4 == 0 && year % 100 != 0){
            printf("闰年\n", year);
        }
        else if (year % 400 == 0){
            printf("闰年\n", year);
        }
        else{
            printf("平年\n", year);
        }
        return 0;
    }

测试用例：等价类划分法：①被4整除且被100整除 ②被4整除但不被100整除 ③被400整除 ④不被400整除但是被4且100整除 ⑤奇数 ⑥一些边界，如0，如当前年份，如机器最大整数等

## 34.请你说一说简单用户界面登陆过程都需要做哪些分析

一、功能测试

1.输入正确的用户名和密码，点击提交按钮，验证是否能正确登录。

2.输入错误的用户名或者密码,验证登录会失败，并且提示相应的错误信息。

3.登录成功后能否能否跳转到正确的页面

4.用户名和密码，如果太短或者太长，应该怎么处理

5.用户名和密码，中有特殊字符（比如空格），和其他非英文的情况

6.记住用户名的功能

7.登陆失败后，不能记录密码的功能

8.用户名和密码前后有空格的处理

9.密码是否非明文显示显示，使用星号圆点等符号代替。

10.牵扯到验证码的，还要考虑文字是否扭曲过度导致辨认难度大，考虑颜色（色盲使 用者），刷新或换一个按钮是否好用

11.登录页面中的注册、忘记密码，登出用另一帐号登陆等链接是否正确

12.输入密码的时候，大写键盘开启的时候要有提示信息。

13.什么都不输入，点击提交按钮，检查提示信息。

二、界面测试 1.布局是否合理，testbox和按钮是否整齐。 2.testbox和按钮的长度，高度是否复合要求。 3. 界面的设计风格是否与UI的设计风格统一。 4. 界面中的文字简洁易懂，没有错别字

三、性能测试 1.打开登录页面，需要的时间是否在需求要求的时间内。 2.输入正确的用户名和密码后，检查登录成功跳转到新页面的时间是否在需求要求的时间内。 3.模拟大量用户同时登陆，检查一定压力下能否正常登陆跳转。

四、安全性测试 1.登录成功后生成的Cookie，是否是httponly (否则容易被脚本盗取)。 2.用户名和密码是否通过加密的方式，发送给Web服务器。 3.用户名和密码的验证，应该是用服务器端验证， 而不能单单是在客户端用javascript 验证。 4.用户名和密码的输入框，应该屏蔽SQL注入攻击。 5.用户名和密码的的输入框，应该禁止输入脚本 （防止XSS攻击）。 6.防止暴力破解，检测是否有错误登陆的次数限制。 7. 是否支持多用户在同一机器上登录。 8. 同一用户能否在多台机器上登录。

五、可用性测试 1. 是否可以全用键盘操作，是否有快捷键。 2. 输入用户名，密码后按回车，是否可以登陆。 3. 输入框能否可以以Tab键切换。

六、兼容性测试 1.不同浏览器下能否显示正常且功能正常（IE,6,7,8,9, Firefox, Chrome, Safari,等）。 2.同种浏览器不同版本下能否显示正常且功能正常。 3.不同的平台是否能正常工作，比如Windows, Mac。 4.移动设备上是否正常工作，比如Iphone, Andriod。 5.不同的分辨率下显示是否正常。

七、本地化测试 1. 不同语言环境下，页面的显示是否正确。

## 35.请对这个系统做出测试用例：一个系统，多个摄像头，抓拍车牌，识别车牌，上传网上，网上展示

功能：

 1.每个摄像头都能抓拍车牌；

 2.每个摄像头抓拍到的车牌能正常交给系统处理；

 3.系统能够正确识别车牌；

 4.系统能够将识别出的车牌上传；

 5.上传至网络的车牌能够正常展示出来；

一、功能测试 

1.使用正常的车牌，保持车牌静止，检查每个摄像头是否能抓拍车牌；

 2.使用类似非车牌的写有字的纸板，检查每个摄像头是否抓拍；

 3.使用正常的车牌，保持车牌较高速移动，检查每个摄像头是否能抓拍车牌；

 4.在多种情况下检查每个摄像头抓拍到的车牌能否正常交给系统处理，如临时断电、断网后能否正常将数据交给系统；

 5.使用抓拍到的正常的车牌，交由系统处理，检查系统能否识别车牌；

 6.使用非车牌的其他图片，交由系统处理，检查系统能否识别；

 7.在多种情况下检查系统能否将正常识别出的车牌进行上传，如临时断电、断网后未上传数据是否能继续上传；

 8.构造非车牌的其他内容的数据，检查系统能否将异常内容进行上传；

 9.检查上传至网络的车牌能否正常展示出来；

 10.上传非车牌的其他内容的数据，检查能否正常显示出来。 

二、性能测试 

1.同时向一个摄像头展示多个静止的车牌，检查摄像头能否抓拍到多个车牌；

 2.同时向一个摄像头展示多个较高速运动的车牌，检查摄像头能否抓拍到多个车牌；

 3.抓拍后，检查系统识别车牌的时间是否在需求要求的时间内；

 4.模拟大量抓拍照片同时交由系统处理，检查一定压力下系统能否正常识别车牌；

 5.模拟大量车牌同时上传，检查一定压力下能否上传成功。

 三、安全性测试 

1.检查是否能够通过给车牌加装饰物等方法，使摄像头无法抓拍或抓拍后系统无法正常识别车牌。

## 36.请你对吃鸡游戏进行压力测试

我不玩 1.多人同时登录吃鸡游戏，2.多人同时进行组队、平凡进入退出房间，3.多人聚集一起跳伞、同时开语音、开启、扔手雷、是否出现卡顿。4.页面出现大量物资、空投等。

## 37.请你根据微信登录界面设计测试用例

一、功能测试

 1.输入正确的用户名和密码，点击提交按钮，验证是否能正确登录。

 2.输入错误的用户名或者密码,验证登录会失败，并且提示相应的错误信息。

 3.登录成功后能否能否跳转到正确的页面

 4.检查能否选择不同登录方式进行登录，如使用手机号登录、使用微信号登录或扫码登录。

 5.记住用户名的功能

  6.登陆失败后，不能记录密码的功能

 7.密码是否非明文显示显示，使用星号圆点等符号代替。

 8.有验证码时，还要考虑文字是否扭曲过度导致辨认难度大，考虑颜色、刷新或换一个按钮是否好用

 9.登录页面中的注册、忘记密码，登出用另一帐号登陆等链接是否正确

 10.输入密码的时候，大写键盘开启的时候要有提示信息。

 11.什么都不输入，点击提交按钮，检查提示信息。

 二、界面测试

 1.布局是否合理，testbox和按钮是否整齐。

 2.testbox和按钮的长度，高度是否复合要求。

 3. 界面的设计风格是否与UI的设计风格统一。

 4. 界面中的文字简洁易懂，没有错别字。

 三、性能测试

 1.打开登录页面，需要的时间是否在需求要求的时间内。

 2.输入正确的用户名和密码后，检查登录成功跳转到新页面的时间是否在需求要求的时间内。

 3.模拟大量用户同时登陆，检查一定压力下能否正常登陆跳转。

 四、安全性测试

 1.登录成功后生成的Cookie，是否是httponly (否则容易被脚本盗取)。

 2.用户名和密码是否通过加密的方式，发送给Web服务器。

 3.用户名和密码的验证，应该是用服务器端验证， 而不能单单是在客户端用javascript 验证。

 4.用户名和密码的输入框，应该屏蔽SQL注入攻击。

 5.用户名和密码的的输入框，应该禁止输入脚本 （防止XSS攻击）。

 6.防止暴力破解，检测是否有错误登陆的次数限制。

 7. 是否支持多用户在同一机器上登录。

 8. 同一用户能否在多台机器上登录。

 五、兼容性测试

 1.不同移动平台或PC环境下下能否显示正常且功能正常

 2.同种平台下不同微信版本下能否显示正常且功能正常。

 3.不同的分辨率下显示是否正常。

 七、本地化测试 

 1. 不同语言环境下，页面的显示是否正确。

## 38.请你对朋友圈点赞功能进行测试

1.是否可以正常点赞和取消；

2.点赞的人是否在可见分组里；

3.点赞状态是否能即时更新显示；

4.点赞状态，共同好友是否可见；

5.不同手机，系统显示界面如何； 备注；

6.性能检测，网速快慢对其影响； 

7.点赞显示的是否正确，一行几个；

8.点赞是否按时间进行排序，头像对应的是否正确；

9.是否能在消息列表中显示点赞人的昵称、

10.可扩展性测试，点赞后是否能发表评论；

11.是否在未登录时可查看被点赞的信息。

~转 57~

## 39.如果做一个杯子的检测，你如何测试

1.功能 

（1）水倒水杯容量的一半 

 （2）水倒规定的安全线

 （4）水杯容量刻度与其他水杯一致 

 （5）盖子拧紧水倒不出来 

 （6）烫手验证

2.性能

 （1）使用最大次数或时间

 （2）掉地上不易损坏

 （3）盖子拧到什么程度水倒不出来 

 （4）保温时间长 

 （5）杯子的耐热性

 （6）杯子的耐寒性 

 （7）长时间放置水不会漏

 （8）杯子上放置重物达到什么程度杯子会被损坏

 3.界面 

 （1）外观完整、美观 

 （2）大小与设计一样（高、宽、容量、直径） 

 （3）拿着舒服 

 （4）材质与设计一样 

 （5）杯子上的图案掉落 

 （6）图案遇水溶解 

 4.安全 

 （1）杯子使用的材质毒或细菌的验证 

 （2）高温材质释放毒性 

 （3）低温材质释放毒性

 5.易用性 

 （1）倒水方便 

 （2）喝水方便 

 （3）携带方便 

 （4）使用简单，容易操作

 （5）防滑措施 6.兼容性 

 （1）杯子能够容纳果汁、白水、酒精、汽油等。

 7.震动测试 

 （1）杯子加包装（有填充物），六面震动，检查产品是否能应对铁路/公路/航空运输。

 8.可移植性 

 （1）杯子在不同地方、温度环境下都可以正常使用。

## 40.如何对一个页面进行测试

1、UI测试：页面布局、页面样式检查、控件长度是否够长；显示时，是否会被截断；支持的快捷键，Tab键切换焦点顺序正确性等。

2、功能测试：页面上各类控件的测试范围，测试点。结合控件的实际作用来补充检查点： 比如， 密码框是否*显示， 输入是否做trim处理等。

3、安全测试：输入特殊字符，sql注入，脚本注入测试。后台验证测试，对于较重要的表单 ，绕过js检验后台是否验证；数据传输是否加密处理，比如， 直接请求转发，地址栏直接显示发送字符串？

4、兼容性测试

5、性能测试

## 41.如何对水壶进行测试

1.功能 

 （1）水倒水壶容量的一半 

 （2）水倒规定的安全线 

 （4）水壶容量刻度与其他水壶一致 

 （5）盖子拧紧水倒不出来 

 （6）烫手验证

 2.性能 

 （1）使用最大次数或时间 

 （2）掉地上不易损坏 

 （3）盖子拧到什么程度水倒不出来 

 （4）保温时间长 

 （5）壶的耐热性 

 （6）壶的耐寒性 

 （7）长时间放置水不会漏 

 （8）壶上放置重物达到什么程度壶会被损坏

 3.界面 

 （1）外观完整、美观 

 （2）大小与设计一样（高、宽、容量、直径） 

 （3）拿着舒服 

 （4）材质与设计一样 

 （5）壶上的图案掉落 

 （6）图案遇水溶解

 4.安全 

 （1）壶使用的材质毒或细菌的验证 

 （2）高温材质释放毒性 

 （3）低温材质释放毒性 

 5.易用性 

 （1）倒水方便 

 （2）喝水方便 

 （3）携带方便

 （4）使用简单，容易操作 

 （5）防滑措施 

 6.兼容性 

 （1）壶能够容纳果汁、白水、酒精、汽油等。 7.震动测试 

 （1）壶加包装（有填充物），六面震动，检查产品是否能应对铁路/公路/航空运输。

 8.可移植性 

 （1）壶在不同地方、温度环境下都可以正常使用。

## 42.如何对淘宝搜索框进行测试

一, 功能测试

 1. 输入关键字，查看: 返回结果是否准确，返回的文本长度需限制

 1.1输入可查到结果的正常关键字、词、语句，检索到的内容、链接正确性；

 1.2输入不可查到结果的关键字、词、语句； 

 1.3输入一些特殊的内容，如空、特殊符、标点符、极限值等，可引入等价类划分的方法等；

 2. 结果显示：标题，卖家，销售量，单行/多行，是否有图片

 3. 结果排序：价格 销量 评价 综合

 4.返回结果庞大时，限制第一页的现实量，需支持翻页 

 5. 多选项搜索：关键字 品牌 产地 价格区间 是否天猫 是否全国购

 6. 是否支持模糊搜索，支持通配符的查询

 7, 网速慢的情况下的搜索 

 8. 搜索结果为空的情况 

 9. 未登录情况和登录情况下的搜索（登录情况下 存储用户搜索的关键字/搜索习惯） 

 二.性能测试： 

 1压力测试：在不同发用户数压力下的表现（评价指标如响应时间等）

 2、负载测试：看极限能承载多大的用户量同时正常使用

 3稳定性测试：常规压力下能保持多久持续稳定运行

 4内存测试：有无内存泄漏现象 

 5大数据量测试：如模拟从庞大的海量数据中搜索结果、或搜索出海量的结果后列示出来，看表现如何等等。

 三. 易用性：交互界面的设计是否便于、易于使用 

 1依据不同的查询结果会有相关的人性化提示，查不到时告知？查到时统计条数并告知？有疑似输入条件错误时提示可能正确的输入项等等处理；

 2查询出的结果罗列有序，如按点击率或其他排序规则，确保每次查询出的结果位置按规则列示方便定位，显示字体、字号、色彩便于识别等等； 

 3标题查询、全文检索、模糊查询、容错查询、多关键字组织查询（空格间格开）等实用的检索方式是否正常？ 4输入搜索条件的控件风格设计、位置摆放是否醒目便于使用者注意到，有否快照等快捷查看方式等人性化设计？

 四. 兼容性

 1WINDOWS/LINUX/UNIX等各类操作系统下及各版本条件下的应用 

 2IE/FIREFOX/GOOGLE/360/QQ等各类浏览器下及各版本条件下、各种显示分辨率条件下的应用 

 3SQL/ORACLE/DB2/MYSQL等各类数据库存储情况下的兼容性测试 

 4简体中文、繁体中文、英文等各类语种软件平台下的兼容性测试

 5IPHONE/IPAD、安卓等各类移动应用平台下的兼容性测试

 6与各相关的监控程序的兼容性测试，如输入法、杀毒、监控、防火墙等工具同时使用 

 五. 安全性 

 1被删除、加密、授权的数据，不允许被SQL注入等攻击方式查出来的，是否有安全控制设计；

 2录入一些数据库查询的保留字符，如单引号、%等等，造成查询SQL拼接出的语句产生漏洞，如可以查出所有数据等等，这方面要有一些黑客攻击的思想并引入一些工具和技术，如爬网等。

 3通过白盒测试技术，检查一下在程序设计上是否存在安全方面的隐患；

 4对涉及国家安全、法律禁止的内容是否进行了相关的过滤和控制；

## 43.如何对一瓶矿泉水进行测试

界面测试:查看外观是否美观 功能度：查看水瓶漏不漏；瓶中水能不能被喝到 安全性：瓶子的材质有没有毒或细菌 可靠性：从不同高度落下的损坏程度 可移植性：再不同的地方、温度等环境下是否都可以正常使用 兼容性：是否能够容纳果汁、白水、酒精、汽油等 易用性：是否烫手、是否有防滑措施、是否方便饮用 用户文档：使用手册是否对的用法、限制、使用条件等有详细描述 疲劳测试：将盛上水（案例一）放24小时检查泄漏时间和情况；盛上汽油（案例二）放24小时检查泄漏时间和情况等 压力测试：用根针并在针上面不断加重量，看压强多大时会穿透 跌落测试:测试在何种高度跌落会破坏水瓶

## 44.如何测试登陆界面

一、功能测试

 1.输入正确的用户名和密码，点击提交按钮，验证是否能正确登录。

 2.输入错误的用户名或者密码,验证登录会失败，并且提示相应的错误信息。 

 3.登录成功后能否能否跳转到正确的页面 

 4.用户名和密码，如果太短或者太长，应该怎么处理 

 5.用户名和密码，中有特殊字符（比如空格），和其他非英文的情况 

 6.记住用户名的功能

 7.登陆失败后，不能记录密码的功能

 8.用户名和密码前后有空格的处理 

 9.密码是否非明文显示显示，使用星号圆点等符号代替。

 10.牵扯到验证码的，还要考虑文字是否扭曲过度导致辨认难度大，考虑颜色（色盲使 用者），刷新或换一个按钮是否好用 

 11.登录页面中的注册、忘记密码，登出用另一帐号登陆等链接是否正确 

 12.输入密码的时候，大写键盘开启的时候要有提示信息。 

 13.什么都不输入，点击提交按钮，检查提示信息。

 二、界面测试

 1.布局是否合理，testbox和按钮是否整齐。

2.testbox和按钮的长度，高度是否复合要求。

 3. 界面的设计风格是否与UI的设计风格统一。 

 4. 界面中的文字简洁易懂，没有错别字。

 三、性能测试 

 1.打开登录页面，需要的时间是否在需求要求的时间内。

 2.输入正确的用户名和密码后，检查登录成功跳转到新页面的时间是否在需求要求的时间内。

 3.模拟大量用户同时登陆，检查一定压力下能否正常登陆跳转。

 四、安全性测试 

 1.登录成功后生成的Cookie，是否是httponly (否则容易被脚本盗取)。

 2.用户名和密码是否通过加密的方式，发送给Web服务器。

 3.用户名和密码的验证，应该是用服务器端验证， 而不能单单是在客户端用javascript 验证。 

 4.用户名和密码的输入框，应该屏蔽SQL注入攻击。

 5.用户名和密码的的输入框，应该禁止输入脚本 （防止XSS攻击）。

 6.防止暴力破解，检测是否有错误登陆的次数限制。

 7. 是否支持多用户在同一机器上登录。

 8. 同一用户能否在多台机器上登录。

 五、可用性测试 

 1. 是否可以全用键盘操作，是否有快捷键。

 2. 输入用户名，密码后按回车，是否可以登陆。

 3. 输入框能否可以以Tab键切换。

 六、兼容性测试 

 1.不同浏览器下能否显示正常且功能正常（IE,6,7,8,9, Firefox, Chrome, Safari,等）。

 2.同种浏览器不同版本下能否显示正常且功能正常。

 2.不同的平台是否能正常工作，比如Windows, Mac。

 3.移动设备上是否正常工作，比如Iphone, Andriod。 

 4.不同的分辨率下显示是否正常。

 七、本地化测试 

 1. 不同语言环境下，页面的显示是否正确。

## 45.请你说一下jmeter

没用过，但是可以学

## 46.请你进行测试：前端下拉框实现，测试下拉框定位方式

Selenium+Python自动化测试对下拉菜单的定位1.通过selenium.webdriver.support.ui的Select进行定位下拉菜单如下：定位代码：from selenium.webdriver.support.ui import Select # 通过index进行选择 Select(driver.find_element_by_id("gender")).select_by_index(1) # 通过value进行选择 Select(driver.find_element_by_id("gender")).select_by_value("2") # 通过选项文字进行选择 Select(driver.find_element_by_id("gender")).select_by_visible_text("Male") 定位代码：# 先定位到下拉菜单

drop_down = driver.find_element_by_css_selector("div#select2_contner > ul") # 再对下拉菜单中的选项进行选择

drop_down.find_element_by_id("li2_input_2").click()

## 47.请你来聊一聊appium断言

略

## 48.请你来说一下购物车的测试用例

1.界面测试 • 界面布局、排版是否合理；文字是否显示清晰；不同卖家的商品是否区分明显。

 2.功能测试 未登录时： • 将商品加入购物车，页面跳转到登录页面，登录成功后购物车数量增加； • 点击购物车菜单，页面跳转到登录页面。 登录后： • 所有链接是否跳转正确； • 商品是否可以成功加入购物车； • 购物车商品总数是否有限制； • 商品总数是否正确； • 全选功能是否好用； • 删除功能是否好用； • 填写委托单功能是否好用； • 委托单中填写的价格是否正确显示； • 价格总计是否正确； • 商品文字太长时是否显示完整； • 店铺名字太长时是否显示完整； • 创新券商品是否打标； • 购物车中下架的商品是否有特殊标识； • 新加入购物车商品排序（添加购物车中存在店铺的商品和购物车中不存在店铺的商品）； • 是否支持TAB、ENTER等快捷键； • 商品删除后商品总数是否减少； • 购物车结算功能是否好用。

 3.兼容性测试 • 不同浏览器测试。 

 4.易用性测试 • 删除功能是否有提示；是否有回到顶部的功能；商品过多时结算按钮是否可以浮动显示。

 5.性能测试 • 压力测试；并发测试。

## 49.请你进行一下弱网模拟

配置参数解析：

bandwidth —— 带宽，即上行、下行数据传输速度

utilisation —— 带宽可用率，大部分modern是100% round-trip latency —— 第一个请求的时延，单位是ms。

MTU —— 最大传输单元，即TCP包的最大size，可以更真实模拟TCP层，每次传输的分包情况。

Releability —— 指连接的可靠性。这里指的是10kb的可靠率。用于模拟网络不稳定。

Stability —— 连接稳定性，也会影响带宽可用性。用于模拟移动网络，移动网络连接一般不可靠。 使用chrome的webview调试工具，缺点是只适用于web页面的弱网模拟。

## 50.你写的测试程序是怎么样的，你写过前端、后端程序吗？

1、指出需要的新特性；2、为新特性编写概要代码；3、为特性的概要编写虚设代码；4、重构代码

## 51.请问测试路由器怎么测，用命令行还是界面

可以采用lperf这个命令， Lperf是一个网络性能测试工具，可以测量最大tcp和udp带宽，具有多种参数和特性，可以记录带宽，延迟抖动，数据包丢失，通过这些信息可以发现网络问题，检查网络质量，定位网络瓶颈。 iperf的使用非常简单，测试的原理是在wan口连接一台PC机，在LAN口连接一台PC，两边分别运行iperf服务端和客户端模式，用来测量LAN->WAN和WAN->LAN性能。具体命令如下： 服务端：iperf -s -w 1m 客户端：iperf -c <server ip=""> -w 1m -t 20 -P 10 含义是TCP wndowsize 为1MByte，测试时间是20s，线程是10。

## 52.请你回答一下如何测试手机开机键？

功能测试： 按下开机键，屏幕能否亮起 性能测试： 按下开机键，屏幕能否在规定时间内亮起 压力测试 连续多次按下开机键，观察屏幕是否能一直亮起，到多久时间失灵 健壮性测试 给定一个中了病毒的手机或者是淘汰许久的老机子，安歇开机键观察屏幕能否亮起 可靠性测试 连续按下开机键有限次数，比如1万次，记录屏幕未亮起的次数 可用性测试 开机键按下费不费力，开机键的形状设计是否贴合手指，开机键的位置设计是否方便

## 53.请问你遇到过哪些印象深刻的bug，接口测试出现bug的原因有哪些？

XXXXXXX

## 54.你在做项目中有做过压力测试吗，怎么做

（1）确定性能需求、（2）制定压测计划 （3）设计压测场景 （4）搭建压测环境 （5）编写压测脚本 （6）执行压测用例 （7）观察性能结果并分析 （8）输出测试报告

## 55.请问你在项目中关于功能测试和接口测试是怎么做的

功能测试： 首先制定测试计划，然后进行测试设计，将在测试计划阶段指定的测试活动分解，进而细化，为若干个可执行程序的子测试过程，然后执行测试，按照测试计划使用测试用例对待测项目进行逐一的，详细的排查分析评估，最后对测试结果进行统计和分析，

接口测试： 什么是接口（API） API全称Application Programming Interface，这里面我们其实不用去关注AP，只需要I上就可以。一个API就是一个Interface。我们无时不刻不在使用interfaces。我们乘坐电梯里面的按钮是一个interface。

功能测试：1、参与需求评审会、明确测试目标和测试内容2、编写测试计划3、需求分析，提取测试点，编写测试用例4、测试用例评审5、执行冒烟测试，通过后执行系统测试，提bug6、bug回归测试7、轮次测试完毕后，编写测试报告8、投产评审9、投产

接口测试：1、明确功能需求2、分析接口文档3、设计接口测试用例4、执行测试5、回归测试6、编写测试报告

## 56.请问你有用过什么测试工具吗，用过哪些？

抓包工具 串口调式工具

## 57.请你设计一个微信朋友圈点赞的测试用例

功能测试： 点赞某条朋友圈，验证是否成功 接口测试： 点赞朋友圈，验证朋友能否收到提示信息 性能测试 点赞朋友圈，是否在规定时间显示结果，是否在规定时间在朋友手机上进行提示 兼容性测试 在不同的终端比如ipad,手机上点赞朋友圈，验证是否成功

## 58.请问如果用户点击微博的关注图标但是app上面没有反应，应该怎么排查这个问题

首先进行抓包，观察请求数据，有以下几种可能：1、抓包时，点击关注按钮，没有发送关联请求，那么这个问题得反应给前端开发让他修改。2、发送了请求，但是请求的参数错误，也需要前端修改。3、请求数据都正确，但是后端返回的结果错误，或者报404等错误，得让后端进行排查。

## 59.在做测试的过程中，假如前端和后端吵起来了都在踢皮球觉得对方该改代码，你怎么办？

此时就应该找技术领导拍板或leader们基于安全性、性能、可测试性、可维护性讨论敲定一个解决方案，做到开发环境方便开发，线上环境少配置 少依赖、少出错机会。

## 60.如果广东用户头条app刷不出东西了，你应该怎么排查问题

1、检查网络连接是否稳定，更换网络尝试

 2、更新头条版本尝试 

3、清除app缓存，应用数据

## 61.请问如何判断一个单向链表存在回路

    bool hasCycle(ListNode *head) {
            if(head == nullptr){
                return false;
            }
            ListNode* fast = head;
            ListNode* slow = head;
            while(fast != nullptr && fast->next != nullptr){
                fast = fast->next->next;
                slow = slow->next;
                if(fast == slow){
                    return true;
                }
            }
            return false;
        }

快慢指针 快走2 慢走1

## 62.请问如何判断两个链表是否相交

    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
            if(headA==NULL)return NULL;
            if(headB==NULL)return NULL;
            ListNode*pa=headA;
            ListNode*pb=headB;
            while(pa!=pb){
                pa=pa==nullptr?headB:pa->next;
                pb=pb==nullptr?headA:pb->next;
            }
            return pa;
        }

首先，我们需要明确一个链表如果存在相交，那么一定是形成一个“Y”字。

所以第一步：先计算两个链表总长度。将长链表的指针移动到和短链表一样的地方。

同时向下一步运行，如果在中途出现相等的情况就说明是相交的。

反之，当两条链表下一个都为空时，则是不相交的。

## 63.循环链表插入元素

    #include <iostream>
    using namespace std;
    
    struct ListNode {
        int value;
        ListNode *next;
        ListNode(int x) : value(x), next(nullptr){}
    };
    
    
    ListNode* insertIntoCircularLinkedList(ListNode *head, it val) {
        ListNode* newNode = new ListNode(val);
        if (!head) {
            // 如果链表为空，新节点指向自己，形成一个环
            newNode->next = newNode;
            return newNode;
        }
    
        ListNode* current = head;
        while (true) {
            // 如果当前节点的下一个节点是头节点，或者找到了合适的插入位置
            if (current->next == head || (current->value <= val && val <= current->next->value) || (current->value > current->next->value && (val < current->next->value || val > current->value))) {
                // 插入新节点
                newNode->next = current->next;
                current->next = newNode;
                break;
            }
            current = current->next;
        }
        return head;
    }
    
    
    int main() {
        // 创建循环链表示例: 3 -> 4 -> 1 -> ...
        ListNode* head = new ListNode(3);
        head->next = new ListNode(4);
        head->next->next = new ListNode(1);
        head->next->next->next = head; // 创建环
    
        // 插入新元素
        head = insertIntoCircularLinkedList(head, 2);
    
        // 打印验证
        ListNode* temp = head;
        for (int i = 0; i < 4; ++i) { // 只打印四个元素避免无限循环
            cout << temp->value << " -> ";
            temp = temp->next;
        }
        cout << "(回到头节点)" << endl;
    
        return 0;
    }

## 64.合并两个排序数组

    ListNode* Merge(ListNode* pHead1, ListNode* pHead2) {
            // write code here
            if(pHead1==nullptr){
                return pHead2;
            }
            if(pHead2==nullptr){
                return pHead1;
            }
            ListNode* head = new ListNode(0);
            ListNode* curr = head;
            while(pHead1 && pHead2){
                if(pHead1->val <= pHead2->val){
                    curr->next = pHead1;
                    pHead1 = pHead1->next;
                }
                else{
                    curr->next = pHead2;
                    pHead2 = pHead2->next;
                }
                curr = curr->next;
            }
            if(pHead1){
                curr->next=pHead1;
            }
            else{
                curr->next=pHead2;
        }
        return head->next;
    }

## 65.最大子数组问题（要求时间复杂度最佳）

    #include <iostream>
    using namespace std;
    
    int MaxSubSum(int *arr, int len) {
        int MaxSum = 0;
        int CurSum = 0;
        for(int i = 0; i < len; i++) {
            CurSum += arr[i];
            if(CurSum > MaxSum) {
                MaxSum = CurSum;
            }
            if(CurSum < 0) {
                CurSum = 0;
            }
        }
        return MaxSum;
    }
    
    int main() {
        int arr[] = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
        int len = sizeof(arr) / sizeof(arr[0]);
        int maxSum = MaxSubSum(arr, len);
        cout << "The maximum subarray sum is: " << maxSum << endl;
        return 0;
    }

## 66.写出一个函数，输入是两个数组，输出是将两个数组中所有元素排序以后用一个数组输出。

    #include <iostream>
    #include <vector>
    #include <algorithm> // 用于std::sort
    
    void mergeAndSortArrays(const std::vector<int>& arr1, const std::vector<int>& arr2, std::vector<int>& result) {
        // 将两个数组的元素合并到result中
        result.clear(); // 确保result是空的
        result.insert(result.end(), arr1.begin(), arr1.end()); // 将arr1的元素添加到result
        result.insert(result.end(), arr2.begin(), arr2.end()); // 将arr2的元素添加到result
    
        // 对result数组中的元素进行排序
        std::sort(result.begin(), result.end());
    }
    
    int main() {
        std::vector<int> arr1 = {5, 3, 1};
        std::vector<int> arr2 = {4, 2, 6};
        std::vector<int> result;
    
        mergeAndSortArrays(arr1, arr2, result);
    
        // 打印排序后合并的数组
        std::cout << "Merged and Sorted Array: ";
        for (int num : result) {
            std::cout << num << " ";
        }
        std::cout << std::endl;
    
        return 0;
    }

## 67.请问如何防止数组越界

1.使用标准容器类

2.显式检查索引值

3.使用固定大小的循环

4.边界检查宏或内联函数

5.使用现代C++特性

6.单元测试

## 68.请回答数组和链表的区别，以及优缺点，另外有没有什么办法能够结合两者的优点

1.数组： 数组是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素。但是如果要在数组中增加一个元素，需要移动大量元素，在内存中空出一个元素的空间，然后将要增加的元素放在其中。同样的道理，如果想删除一个元素，同样需要移动大量元素去填掉被移动的元素。如果应用需要快速访问数据，很少插入和删除元素，就应该用数组。

2.链表： 链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起，每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针。如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置。但是增加和删除一个元素对于链表数据结构就非常简单了，只要修改元素中的指针就可以了。如果应用需要经常插入和删除元素你就需要用链表。

3.区别：

（1）存储位置上： 数组逻辑上相邻的元素在物理存储位置上也相邻，而链表不一定；

（2）存储空间上： 链表存放的内存空间可以是连续的，也可以是不连续的，数组则是连续的一段内存空间。一般情况下存放相同多的数据数组占用较小的内存，而链表还需要存放其前驱和后继的空间。

（3）长度的可变性： 链表的长度是按实际需要可以伸缩的，而数组的长度是在定义时要给定的，如果存放的数据个数超过了数组的初始大小，则会出现溢出现象。

（4）按序号查找时，数组可以随机访问，时间复杂度为O(1)，而链表不支持随机访问，平均需要O(n)；

（5）按值查找时，若数组无序，数组和链表时间复杂度均为O(1)，但是当数组有序时，可以采用折半查找将时间复杂度降为O(logn)；

（6）插入和删除时，数组平均需要移动n/2个元素，而链表只需修改指针即可；

（7）空间分配方面： 数组在静态存储分配情形下，存储元素数量受限制，动态存储分配情形下，虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且如果内存中没有更大块连续存储空间将导致分配失败；即数组从栈中分配空间,，对于程序员方便快速,但自由度小。

链表存储的节点空间只在需要的时候申请分配，只要内存中有空间就可以分配，操作比较灵活高效；即链表从堆中分配空间, 自由度大但申请管理比较麻烦。 哈希表可以结合数组和链表的优点

## 69.请问Java中collection的sort方法，默认的排序方法是什么

排序方法是归并排序 --------.......无语了

## 70.合并两个排序数组

    #include <iostream>
    #include <vector>
    
    std::vector<int> mergeSortedArrays(const std::vector<int>& arr1, const std::vector<int>& arr2) {
        std::vector<int> result;
        int i = 0, j = 0;
        while (i < arr1.size() && j < arr2.size()) {
            if (arr1[i] < arr2[j]) {
                result.push_back(arr1[i]);
                ++i;
            } else {
                result.push_back(arr2[j]);
                ++j;
            }
        }
        // 复制剩余的元素
        while (i < arr1.size()) {
            result.push_back(arr1[i]);
            ++i;
        }
        while (j < arr2.size()) {
            result.push_back(arr2[j]);
            ++j;
        }
        return result;
    }
    
    int main() {
        std::vector<int> arr1 = {1, 3, 5, 7};
        std::vector<int> arr2 = {2, 4, 6, 8};
        std::vector<int> mergedArray = mergeSortedArrays(arr1, arr2);
        std::cout << "Merged Array: ";
        for (int num : mergedArray) {
            std::cout << num << " ";
        }
        std::cout << std::endl;
        return 0;
    }

## 71.冒泡排序

    //冒泡排序
    void bubbleSort(std::vector<int>& nums) {
        int n = nums.size();
        for (int j = n; j > 0; j--) {
            bool flag = true;
            for (int i = 0; i < j - 1; i++) {
                //需要交换，代表是无序的
                if (nums[i] > nums[i + 1]) {
                    flag = false;
                    std::swap(nums[i], nums[i + 1]);
                }
            }
            if (flag == true) {
                return;
            }
        }
    }

## 72.统计排序数组中出现次数最多的元素出现的次数？

    #include <iostream>
    #include <vector>
    
    std::pair<int, int> findMostFrequent(const std::vector<int>& sortedArray) {
        int maxCount = 1; // 最大出现次数
        int currentCount = 1; // 当前元素的出现次数
        int mostFrequentElement = sortedArray[0]; // 最频繁出现的元素
        int currentElement = sortedArray[0]; // 当前正在检查的元素
        for (size_t i = 1; i < sortedArray.size(); ++i) {
            if (sortedArray[i] == currentElement) {
                ++currentCount;
            } else {
                if (currentCount > maxCount) {
                    maxCount = currentCount;
                    mostFrequentElement = currentElement;
                }
                currentElement = sortedArray[i];
                currentCount = 1;
            }
        }
        // 最后一个元素的处理
        if (currentCount > maxCount) {
            maxCount = currentCount;
            mostFrequentElement = currentElement;
        }
        return {mostFrequentElement, maxCount};
    }
    
    int main() {
        std::vector<int> sortedArray = {1, 2, 2, 2, 3, 3, 4, 4, 4, 4, 5};
        auto result = findMostFrequent(sortedArray);
        std::cout << "Most frequent element: " << result.first << ", Count: " << result.second << std::endl;
        return 0;
    }

## 73.请你说一下Spring AOP

即面向切面编程，可以说是OOP的补充和完善。

## 74.请问J2EE 上 request 请求先经过谁 然后再转交到 SpringMVC上

DispatcherServlet

## 75.请你回答一下Filter主要是做什么的，filter和Servlet先过哪个，FilterChn 是什么意思

Filter：过滤器，过滤器是一些web应用程序组件，可以绑定到一个web应用程序中，但是与其他web应用程序组件不同的是，过滤器是链在容器的处理过程中的，这就意味它们会在servlet处理器之前访问一个进入的请求，并且在外发响应信息返回到客户前访问这些响应信息。这种访问使得过滤器可以检查并修改请求和响应的内容。 filter和Servlet先过哪个 先执行filter再执行servlet，servlet执行完后再执行filter FilterChn 是什么意思 过滤链FilterChn 两个过滤器，EncodingFilter负责设置编码，SecurityFilter负责控制权限，服务器会按照web.xml中过滤器定义的先后循序组装成一条链，然后一次执行其中的doFilter()方法。执行的顺序就如下图所示，执行第一个过滤器的chn.doFilter()之前的代码，第二个过滤器的chn.doFilter()之前的代码，请求的资源，第二个过滤器的chn.doFilter()之后的代码，第一个过滤器的chn.doFilter()之后的代码，最后返回响应。

## 76.请你说一说关于linux查看进程

1.win:ps -aux | grep 进程名

2.linux:ps -ef | grep 进程名

## 77.请你说几个基本Linux命令

1.cd 切换目录，2.mkdir创建目录,3.mv移动或重命名 ,4.cp复制, 5.touch 创建文件 6.vi编辑器，创建文件，7.find查找8.cat/tail/head/less查看 9.ps-ef查看进程 10.ifconfig 查看ip地址 11.rm删除

## 78.请你说一说Linux命令（查看进程、top命令、查看磁盘）

查看进程：

ps 命令：用于列出当前正在运行的进程的快照。

top 命令：实时显示系统的进程状态，包括 CPU 使用率、内存占用、进程 ID 等信息。使用 top 命令：

top 命令：显示系统的实时进程状态。按Shift+M 可以按照内存使用排序进程（最耗内存的进程在顶部）。

查看磁盘：

df 命令：显示文件系统的磁盘空间使用情况，包括每个挂载点的使用空间。

du 命令：用于估算文件和目录的磁盘空间使用情况。

## 79.请你说一下vector的特性

vector特点是： 其容量在需要时可以自动分配，可以在运行时高效地添加元素，本质上是数组形式的存储方式。即在索引可以在常数时间内完成。缺点是在插入或者删除一项时，需要线性时间。但是在尾部插入或者删除，是常数时间的。

## 80.查看端口号、进程的指令是？动态查看日志的指令？怎么判断一个端口存不存在，磁盘满了怎么处理，删除一个目录下的txt文件，你还熟悉其他什么linux指令？

查看端口号的两种指令: netstat –tunlp|grep 端口号 lsof -i:端口号 查询进程的指令 ps -ef |grep 进程 ps:将某个进程显示出来 -A 　显示所有程序。 -e 　此参数的效果和指定"A"参数相同。 -f 　显示UID,PPIP,C与STIME栏位。 动态查看日志

1、先切换到：cd usr/local/tomcat5/logs

2、tl -f catalina.out 

3、这样运行时就可以实时查看运行日志了 怎么判断一个端口存不存在： netstat -anp |grep 端口号，在输出结果中看监控状态为LISTEN表示已经被占用，最后一列显示被服务mysqld占用，查看具体端口号，只要有如图这一行就表示被占用了。 磁盘满了怎么处理

 1. df -h 查看是哪个挂在目录满了，常常是根目录/占满

 2. 快速定位一下应用日志大小情况，比如tomcat日志，应用系统自己的日志等。

 3. 如果能直观地看到日志文件过大，则酌情进行删除。有时候删除日志文件之后再df -h查看空间依然被占满，继续排查。 lsof file_name 查看文件占用进程情况，如果删除的日志正在被某个进程占用，则必须重启或者kill掉进程。

 4. 如果不能直观地排除出是某个日志多大的原因，就需要看一下指定目录下的文件和子目录大小情况，使用du命令。 删除一个目录下的txt文件 find . -name "*.txt" | xargs rm -rf 我还熟悉文本编辑指令。

## 81.请你说一下HTTP的报文段是什么样的？

1. **请求行**：包含请求方法（GET、POST等）、请求的URL和协议版本。
2. **请求头部**：包含多个键值对，描述请求的各种属性，如`Host`、`User-Agent`等。
3. **空行**：仅包含换行符，用于分隔头部和请求体。
4. **请求体**（可选）：包含请求的数据，如在POST请求中发送的表单数据。

## 82.请你回答一下HTTP用的什么连接？

在HTTP/1.0中，默认使用的是短连接。

也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。

但从HTTP/1.1起，默认使用长连接，用以保持连接特性。

使用长连接的HTTP协议，会在响应头有加入这行代码：Connection:keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。

## 83.请你说一下在浏览器中输入一个网址它的运行过程是怎样的？

**总结**

1、DNS解析（1）查找浏览器缓存（2）查找本地DNS解析器缓存（3）查找首选服务器（4）查找根服务器

2、请求解析出的ip及端口号

3、服务器响应数据

4、浏览器解析响应数据

5、关闭连接

1、查询DNS，获取域名对应的IP。 

（1）检查浏览器缓存、检查本地hosts文件是否有这个网址的映射，如果有，就调用这个IP地址映射，解析完成。 

 （2）如果没有，则查找本地DNS解析器缓存是否有这个网址的映射，如果有，返回映射，解析完成。 

 （3）如果没有，则查找填写或分配的首选DNS服务器，称为本地DNS服务器。服务器接收到查询时： 如果要查询的域名包含在本地配置区域资源中，返回解析结果，查询结束，此解析具有权威性。 如果要查询的域名不由本地DNS服务器区域解析，但服务器缓存了此网址的映射关系，返回解析结果，查询结束，此解析不具有权威性。 

 （4）如果本地DNS服务器也失效：  如果未采用转发模式（迭代），本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后，会判断这个域名（如.com）是谁来授权管理，并返回一个负责该顶级域名服务器的IP，本地DNS服务器收到顶级域名服务器IP信息后，继续向该顶级域名服务器IP发送请求，该服务器如果无法解析，则会找到负责这个域名的下一级DNS服务器（如[http://baidu.com](http://baidu.com/)）的IP给本地DNS服务器，循环往复直至查询到映射，将解析结果返回本地DNS服务器，再由本地DNS服务器返回解析结果，查询完成。  如果采用转发模式（递归），则此DNS服务器就会把请求转发至上一级DNS服务器，如果上一级DNS服务器不能解析，则继续向上请求。最终将解析结果依次返回本地DNS服务器，本地DNS服务器再返回给客户机，查询完成。

 2、得到目标服务器的IP地址及端口号（http 80端口，https 443端口），会调用系统库函数socket，请求一个TCP流套接字。客户端向服务器发送HTTP请求报文： 

 （1）应用层：客户端发送HTTP请求报文。 

 （2）传输层：（加入源端口、目的端口）建立连接。实际发送数据之前，三次握手客户端和服务器建立起一个TCP连接。 

 （3）网络层：（加入IP头）路由寻址。 

 （4）数据链路层：（加入frame头）传输数据。 

 （5）物理层：物理传输bit。

 3、服务器端经过物理层→数据链路层→网络层→传输层→应用层，解析请求报文，发送HTTP响应报文。

 4、关闭连接，TCP四次挥手。

 5、客户端解析HTTP响应报文，浏览器开始显示HTML

## 84.请你说一说http请求报文

1、请求方法 GET：请求获取Request——URL所标识的资源 POST：在Request——URL所标识的资源后附加资源 HEAD：请求获取由Request——URL所标识的资源的响应消息报头 PUT：请求服务器存储一个资源，由Request——URL作为其标识 DELETE：请求服务器删除由Request——URL所标识的资源 TRACE：请求服务器回送收到的请求信息（用于测试和诊断） CONNECT：保留 OPTIONS：请求查询服务器性能 

 2、URL URI全名为Uniform Resource Indentifier（统一资源标识），用来唯一的标识一个资源，是一个通用的概念，URI由两个主要的子集URL和URN组成。URL全名为Uniform Resource Locator（统一资源定位），通过描述资源的位置来标识资源。URN全名为Uniform Resource Name（统一资源命名），通过资源的名字来标识资源，与其所处的位置无关，这样即使资源的位置发生变动，其URN也不会变化。 

 3、协议版本 格式为HTTP/主版本号.次版本号，常用为：HTTP/1.1 HTTP/1.0 

 4、请求头部 Host：接受请求的服务器地址，可以是IP或者是域名 User-Agent：发送请求的应用名称 Connection：指定与连接相关的属性，例如（Keep_Alive，长连接） Accept-Charset：通知服务器端可以发送的编码格式 Accept-Encoding：通知服务器端可以发送的数据压缩格式 Accept-Language：通知服务器端可以发送的语言

## 85.请你说一下tcp和udp的区别

1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接 

2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保 证可靠交付 

 3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等） 4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信 

 5、TCP首部开销20字节;UDP的首部开销小，只有8个字节

 6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

## 86.请你说一下为什么tcp可靠，哪些方法保证可靠

[1] 确认和重传机制 建立连接时三次握手同步双方的“序列号 + 确认号 + 窗口大小信息”，是确认重传、流控的基础 传输过程中，如果Checksum校验失败、丢包或延时，发送端重传。 

 [2] 数据排序 TCP有专门的序列号SN字段，可提供数据re-order

 [3] 流量控制 滑动窗口和计时器的使用。TCP窗口中会指明双方能够发送接收的最大数据量，发送方通过维持一个发送滑动窗口来确保不会发生由于发送方报文发送太快接收方无法及时处理的问题。

 [4] 拥塞控制 TCP的拥塞控制由4个核心算法组成： “慢启动”（Slow Start） “拥塞避免”（Congestion avoidance） “快速重传 ”（Fast Retransmit） “快速恢复”（Fast Recovery）

## 87.请你说一说TCP的流量控制

滑动窗口机制： 滑动窗口协议的基本原理就是在任意时刻，发送方都维持了一个连续的允许发送的帧的序号，称为发送窗口；同时，接收方也维持了一个连续的允许接收的帧的序号，称为接收窗口。发送窗口和接收窗口的序号的上下界不一定要一样，甚至大小也可以不同。不同的滑动窗口协议窗口大小一般不同。发送方窗口内的序列号代表了那些已经被发送，但是还没有被确认的帧，或者是那些可以被发送的帧。 举例： 发送和接受方都会维护一个数据帧的序列，这个序列被称作窗口。发送方的窗口大小由接受方确定，目的在于控制发送速度，以免接受方的缓存不够大，而导致溢出，同时控制流量也可以避免网络拥塞。图中的4,5,6号数据帧已经被发送出去，但是未收到关联的ACK，7,8,9帧则是等待发送。可以看出发送端的窗口大小为6，这是由接受端告知的（事实上必须考虑拥塞窗口cwnd，这里暂且考虑cwnd>rwnd）。此时如果发送端收到4号ACK，则窗口的左边缘向右收缩，窗口的右边缘则向右扩展，此时窗口就向前“滑动了”，即数据帧10也可以被发送。

## 88.请你回答一下TCP三次握手，以及为什么不是两次

第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。

第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

为什么不是两次： 在服务端对客户端的请求进行回应(第二次握手)后，就会理所当然的认为连接已建立，而如果客户端并没有收到服务端的回应呢？此时，客户端仍认为连接未建立，服务端会对已建立的连接保存必要的资源，如果大量的这种情况，服务端会崩溃。

## 89.请你说一说osi七层模型

物理层，链路层，网络层，传输层，会话层，表示层，应用层

## 90.请你说一说DNS解析过程

DNS解析：

1.查浏览器缓存，查到则返回IP 。

2.没有查到浏览器缓存就去DNS解析器缓存里查。

3.还没查到就去本地DNS服务器查

4.本地DNS失效就去向13台根DNS服务器请求

5.根DNS服务器返回顶级域名逐层向下查询直到查询到并返回映射。

## 91.请你说一下常用设计模式

单例模式（Singleton Pattern）：确保一个类只有一个实例，并提供一个全局访问点。

工厂模式（Factory Pattern）：定义一个创建对象的接口，但由子类决定要实例化的类是哪一个。

观察者模式（Observer Pattern）：定义了一种一对多的依赖关系，当一个对象的状态发生改变时，其依赖的对象都会收到通知。

装饰器模式（Decorator Pattern）：动态地给一个对象添加新的功能，是继承的一种替代方案。

适配器模式（Adapter Pattern）：将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的类可以一起工作。

策略模式（Strategy Pattern）：定义了一系列算法，将每个算法封装起来，使它们可以互相替换。

模板方法模式（Template Method Pattern）：定义了一个操作中的算法框架，将一些步骤的实现延迟到子类中。

建造者模式（Builder Pattern）：将一个复杂对象的构建与表示分离，使同样的构建过程可以创建不同的表示。

原型模式（Prototype Pattern）：通过复制现有对象来创建新对象，而不是通过实例化对象来创建。

责任链模式（Chain of Responsibility Pattern）：将请求的发送者和接收者解耦，使多个对象都有机会处理该请求，直到有一个对象处理它为止。

## 92.请问设计模式是什么？

设计模式是一种代码设计思想或经验的总结，是面对特定场景特定问题的一种解决方案。它可以提高代码的可读性、可维护性和可扩展性。

## 93.请你手写一下单例模式代码

    #include <iostream>
    
    class Singleton {
    private:
        static Singleton* instance; // Private static pointer to hold the single instance
        int data; // Example member variable
    
        // Private constructor to prevent instantiation
        Singleton() {
            data = 0; // Initialize example member variable
        }
    
    public:
        // Static method to get the single instance of Singleton
        static Singleton* getInstance() {
            if (instance == nullptr) {
                instance = new Singleton(); // Create the instance if it doesn't exist
            }
            return instance; // Return the single instance
        }
    
        // Example method to demonstrate the Singleton instance
        void setData(int value) {
            data = value;
        }
    
        // Example method to demonstrate the Singleton instance
        int getData() {
            return data;
        }
    };

## 94.请你说几个海量数据存储常见问题以及如何解答

例子1：给你A,B两个文件，各存放50亿条URL，每条URL占用64字节，内存限制是4G，让你找出A,B文件共同的URL。 思路：可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。 • 分而治之/hash映射：遍历文件a，对每个url求取，然后根据所取得的值将url分别存储到1000个小文件（记为）中。这样每个小文件的大约为300M。遍历文件b，采取和a相同的方式将url分别存储到1000小文件中（记为）。这样处理后，所有可能相同的url都在对应的小文件（）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。 • hash统计：求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。 例子2：有10个文件，每个文件1G， 每个文件的每一行都存放的是用户的query，每个文件的query都可能重复。要你按照query的频度排序 思路： • hash映射：顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件（记为）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。 • hash统计：找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。注：hash_map(query,query_count)是用来统计每个query的出现次数，不是存储他们的值，出现一次，则count+1。 • 堆/快速/归并排序：利用快速/堆/归并排序按照出现次数进行排序。将排序好的query和对应的query_cout输出到文件中。这样得到了10个排好序的文件（记为）。对这10个文件进行归并排序（内排序与外排序相结合）。 例子3：有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16个字节，内存限制大小是1M。返回频数最高的100个词 思路： • 分而治之/hash映射：顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为x0,x1,...x4999）中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。 • hash统计：对每个小文件，采用trie树/hash_map等统计每个文件中出现的词以及相应的频率。 • 堆/归并排序：取出出现频率最大的100个词（可以用含100个结点的最小堆），并把100个词及相应的频率存入文件，这样又得到了5000个文件。最后就是把这5000个文件进行归并（类似于归并排序）的过程了。 例子4：海量日志数据，提取出某日访问百度次数最多的那个IP。 思路： • 分而治之/hash映射：针对数据太大，内存受限，只能是：把大文件化成(取模映射)小文件，即16字方针：大而化小，各个击破，缩小规模，逐个解决 • hash统计：当大文件转化了小文件，那么我们便可以采用常规的Hashmap(ip，value)来进行频率统计。 • 堆/快速排序：统计完了之后，便进行排序(可采取堆排序)，得到次数最多的IP。

## 95.请你说一下你用过哪些电商app,并比较他们的好坏

用过淘宝，京东、唯品会、网易考拉、亚马逊 首先淘宝，用的最多，的确买日用品很方便，东西齐全，但是加载首页很慢，不够流畅，此外依旧是假货横行，应当加大打假力度， 京东，只买过U盘，但是退货后钱款没到账，找客服两次未解决，不提了，后面就卸了，没什么印象了 唯品会：排版不行，购物车只能保持十五分钟这个笔者持反对意见 网易考拉:货少但相对淘宝来说可信度比较高，当然价格也比较高，经常缺货 亚马逊：除了运费贵英文看的费力没毛病

## 96.请你说一下分布式和集群的概念。

分布式：是指将不同的业务分布在不同的地方， 集群：是指将几台服务器集中在一起，实现同一业务。 分布式中的每一个节点，都可以做集群，而集群并不一定就是分布式的。

集群有组织性，一台服务器垮了，其它的服务器可以顶上来，而分布式的每一个节点，都完成不同的业务，一个节点垮了，哪这个业务就不可访问了。

## 97.Hadoop你也有了解的，那你有了解他的备份机制吧？请问怎么做到数据保持一致？

不了解

## 98.5只猫 五分钟捉5只老鼠 请问100分钟捉100只老鼠需要多少只猫？

5分钟内，平均1只猫捉一只老鼠，给猫100分钟，则它能抓20只，想要抓到100只，就得X5，所以是5只。

## 99.逻辑题：3升的杯子一个，5升的杯子一个，杯子不规则形状 问怎么得到4升的水 水无限多

1、将3升的装满倒入5升的；

 2、再一次将3升的转满，倒入5升的，把5升装满；

 3、3升杯里剩下的就是1升水；

 4、倒掉5升的，把1升水倒入5升杯；

 5、第三次加满3升杯，倒入5升杯，得到4升水。

## 100.晚上有四个人过桥，一次只能过两个人，但是只有一只手电筒，四个人过桥时间分别是1，2，5，8，求最短过桥时间

假设这四人依次是甲乙丙丁：首先甲和乙过桥,甲带手电筒回来；然后丙和丁过桥,由乙带手电筒回来；最后甲再和乙一起过桥.所以最少用时间是2+1+8+2+2=15（分钟）

## 101.两个容积分别为5升和6升的桶，最后如何只装3升？

第一步：先取来6升水，倒进5升桶的水桶里，即得到6升桶里余下的1升水；

第二步：把5L桶清掉，把取到的1升水放进5升的水桶里保留不动，然后再取6升水，倒进5升的水桶里，6升的桶得到的是2升水，把5L桶清掉，存放这2升水；

第三步：5升水桶有2升水．再取6升水，倒进5升水桶里，原有2L升+3升=5升，这时6升-3升=3升，6升里余下的就是3升水了。

## 102.有十张扑克牌，每次可以只出一张，也可以只出两张，要出完有多少种出法

还有一张牌就出完10张，可能的情况有两种，从9到10和从8到10，已知了从0到9的出法有N种，

如果再知道从0到8的出法有P种，那么从0到10级的出法就是N+P，那么可得出： F(9)=N； F(8)=P； F(10)=N+P； F(10)=F(9)+F(8); 又有： F(1)=1; F(2)=2; 最后推出：F(10)=89

## 103.井盖为什么是圆的

井道大都是圆形的，所以井盖就做成圆形的。 很多井道都是圆形的，所以井盖自然也就是圆形的了。那为什么井大都是圆形的呢？因为建筑学和土木工程学中，圆形通道最有利于保持土壤的压力。 圆的受力更均匀不容易碎裂和塌陷 圆形井盖受力后，会向四周扩散压力，由于扩散均匀不容易碎裂和塌陷。 矩形的井盖由于受力不均匀，导致碎裂的几率远大于圆形。所以通过耐用性方面考虑还是圆形井盖合适。 圆形井盖从任何方向都不会掉落井下，也方便操作 矩形对角线的长度都大于矩形的长和宽。所以在对角线方向把井盖竖起来就容易掉落井下。 相对节省生成材料成本 相对于矩形或者正方形，矩形内切圆形的面积最小，生成用的材料也更少。

## 104.从前有座山，山脚下有5个海盗抢到了100枚金币，每一颗都一样的大小和价值。他们决定通过抽签的方式，按顺序提出分配方案决定金币的归属。 首先，由1号提出方案，5个人进行表决，半数人以上（包括半数）同意时，方案通过，否则他将被扔入大海喂鲨鱼，剩余海盗继续按顺序提出方案，依次类推。 假设每个海盗都是足够理性及机智，会考虑到利害及利益最大化问题，那么，1号海盗提出怎样的分配方案才能顺利通过考验并拿到可能性内最多的金币呢？

海盗分金推理过程： 从后向前推，如果只剩4号和5号的话，5号一定会投反对票让4号喂鲨鱼，以独吞全部金币。所以，4号唯有支持3号才能保命。3号知道这一点，就会提(100，0，0)的分配方案，对4号、5号一毛不拔而将全部金币归为己有，因为他知道4号一无所获也会投赞成票，再加上自己一票他的方案即可通过。不过，2号推知到3号的方案，就会提出(98，0，1，1)的方案，即放弃3号，而给予4号和5号各一枚金币。由于该方案对于4号和5号来说比在3号分配时更为有利，他们将支持他而不希望由3号来分配。这样，2号将拿走98枚金币。不过，2号的方案会被1号所洞悉，1号并将提出(97，0，1，2，0)或(97，0，1，0，2)的方案，即放弃2号，而给3号一枚金币，同时给4号(或5号)2枚金币。由于1号的这一方案对于3号和4号(或5号)来说，相比2号分配时更优，他们将投1号的赞成票，再加上1号自己的票，1号的方案可获通过，97枚金币可轻松落入囊中。

## 105.烧一根不均匀的绳子，从头烧到尾总共需要1个小时，问如何用烧绳子的方法来确定15分钟?

烧两根绳子，1第一根两头一起点，第二根点一头 2第一根烧完后点第二根另一端，从此时起计时，至第二根烧完，即15min（哎不知道出这种题是要干什么）

## 106.两个盲人各买了一白一黑两双袜子，不小心弄混了，问他们自己怎么分成刚好每人一白一黑

额因为袜子一双都是连在一起的，所以把两双袜子扯开，互相给对方一只，即可

## 107.一个圆桌，两个人往上放硬币，只能平铺不能重合，最后一个放的人胜利（接下来硬币无处可放了），问先放的赢还是后放的赢。

这道题会围棋的人一般都知道，只要先手把硬币放在圆桌正中心，随后第二个人无论把硬币放在哪，第一个人都把硬币放在对称的位置，即可，是先放的赢

## 108.请问你有没有写过web测试，怎么写的？

1、先测功能，全面覆盖pm需求，包括关联业务，以及异常情况。

2、再测专项，效率性：网站的相应效率是否达标；

兼容性：不同操作系统，不同浏览器，不同网络；

易用性：产品是否好用，操作是否方便，布局是否合理，页面是否美观。